# 1. 添加依赖

1. 添加依赖：在`pom.xml`文件中添加MyBatis和Spring Boot相关的依赖项。例如：

```xml
xmlCopy code<dependencies>
  <!-- MyBatis -->
  <dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
  </dependency>

  <!-- MySQL Connector -->
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.26</version>
  </dependency>

  <!-- Spring Boot -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <version>2.5.2</version>
  </dependency>
</dependencies>
```



# 2. 配置数据源 application.yml配置

```yaml
spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/test_data_base?useUnicode=true&characterEncoding=UTF-8&useSSL=false&autoReconnect=true&failOverReadOnly=false&serverTimezone=GMT%2B8
    username: root
    password: 123456
    # MySQL JDBC驱动程序的完全限定类名
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 数据源的类型，在本例中设置为HikariDataSource
    type: com.zaxxer.hikari.HikariDataSource
    # 指定应如何初始化数据库架构。在这里，它被设置为“总是”，这意味着它将在每次应用程序启动时初始化。
    initialization-mode: always
    # 指定即使在架构初始化期间出现错误，应用程序是否仍应继续启动
    continue-on-error: true
    # SQL架构脚本文件的位置
    schema:
    - "classpath:db/schema.sql"
    # SQL数据脚本文件的位置
    data:
    - "classpath:db/data.sql"
    # 特定于 Hikari 连接池的配置
    hikari:
      minimum-idle: 5 # 池中空闲连接的最小数量
      connection-test-query: SELECT 1 FROM DUAL # 用于验证连接的查询
      maximum-pool-size: 20 # 池中的最大连接数
      auto-commit: true # 指定是否应自动提交连接
      idle-timeout: 30000 # 连接在关闭之前可以处于空闲状态的最长时间
      pool-name: SpringBootDemoHikariCP # 连接池的名称
      max-lifetime: 60000 # 连接的最长生存期
      connection-timeout: 30000 # 等待来自池的连接的最长时间
logging:
  level: # 用于设置不同包或类的日志级别
    # 这是一个包名，设置了该包下所有类的日志级别为 debug，即输出包括 debug 级别及更高级别的日志信息
    com.xkcoding: debug 
    # 这是另一个包名，设置了该包下所有类的日志级别为 trace，即输出包括 trace 级别及更高级别的日志信息
    com.xkcoding.orm.mybatis.mapper: trace
mybatis:
  configuration:
    # 下划线转驼峰
    map-underscore-to-camel-case: true
  mapper-locations: classpath:mappers/*.xml
  type-aliases-package: com.xkcoding.orm.mybatis.entity

```

## 数据库、数据源、JDBC和ORM框架之间的联系

```sql
  +------------------+
   |   Application    |
   +------------------+
          |  
          |  Requests/Queries
          |  
   +------------------+
   |    Data Source   |
   +------------------+
          |  
          |  Establishes Connection
          |  
   +------------------+
   |       JDBC       |
   +------------------+
          |  
          |  Executes SQL
          |  
   +------------------+
   |    Database      |
   +------------------+
```

解释：

- 应用程序通过数据源来获取与数据库的连接。
- 数据源使用`JDBC`来建立与数据库的连接。
- `JDBC`负责执行SQL语句，并将查询结果返回给数据源。
- 数据源将查询结果返回给应用程序，完成数据库操作。

## 数据源和JDBC的区别

数据源`（DataSource）`是一个提供数据库连接的接口或组件。它包含了与数据库连接相关的配置信息，例如数据库的URL、用户名、密码等。数据源的主要目的是为了管理和提供数据库连接，以便应用程序可以通过它获取数据库连接并执行数据库操作。

`JDBC（Java Database Connectivity）`是Java语言访问数据库的标准API。它提供了一组接口和类，用于连接数据库、执行SQL语句和处理结果。`JDBC`定义了一套规范，使得Java应用程序可以通过驱动程序与不同类型的数据库进行通信。

简而言之，数据源是连接数据库的抽象层，它提供了获取数据库连接的方法，并管理连接的创建和销毁。而`JDBC`是用于实际与数据库进行交互的API，它定义了连接数据库、执行SQL语句和处理结果的方法和规范。

在具体实现上，数据源通常会使用`JDBC`来建立和管理数据库连接。数据源会根据配置信息，使用`JDBC`来创建数据库连接，并将连接提供给应用程序使用。`JDBC`负责底层的连接管理和SQL操作，而数据源则提供了更高级别的抽象，为应用程序提供了方便和简化的数据库连接管理。

## 数据源的类型

| 数据源类型           | 描述                                                         | 区别和作用                                                   |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| HikariDataSource     | HikariCP 是一个高性能的 JDBC 连接池，是 Spring Boot 2.x 默认的连接池实现。 | 提供了快速、高效的连接池，具有较低的资源消耗和高度并发的能力。在 Spring Boot 2.x 中被广泛使用，能够提供优异的数据库连接性能。 |
| TomcatDataSource     | Tomcat JDBC 连接池是 Apache Tomcat 项目的一部分，用于管理和提供 JDBC 连接。 | 在传统的 Java Web 应用中使用较为广泛，是 Tomcat 服务器的默认连接池。具有稳定性和兼容性好的特点，适用于常规的数据库连接需求。 |
| Commons DBCP / DBCP2 | Commons DBCP（DBCP2 是其更新版本）是 Apache 软件基金会的一个开源数据库连接池项目。 | 提供了基本的数据库连接池功能，使用简单，适用于轻量级的应用场景。与 Tomcat 类似，也是传统 Java Web 应用中常用的连接池实现之一。 |
| C3P0                 | C3P0 是一个开源的 JDBC 连接池实现，提供了诸如连接池缓存、连接重用、连接泄漏检测等功能。 | 作为一个稳定而成熟的连接池实现，具有较强的兼容性和可靠性。在较早的 Java Web 应用中被广泛使用，但在性能方面可能不如 HikariCP 等新一代连接池。 |
| BoneCP               | BoneCP 是一个高性能的、并发性能出色的 JDBC 连接池。          | 具有快速启动、低资源消耗等特点，在一些需要高并发数据库访问的应用中表现出色。然而，BoneCP 的开发已停止，推荐使用更先进的连接池实现，如 HikariCP。 |
| DruidDataSource      | Druid 是阿里巴巴开源的一个数据库连接池项目，提供了丰富的监控和扩展功能。 | 具有强大的监控功能和丰富的统计信息，可以实时监控数据库连接池的使用情况。适用于对连接池性能监控要求较高的场景，如需要实时监控连接池状态、慢查询分析等情况。 |
| H2 Embedded Database | H2 是一个内存数据库，可以作为嵌入式数据库使用。              | 适用于开发和测试阶段，可以将数据库嵌入到应用程序中，无需额外的数据库安装和配置。方便快捷，但不适用于生产环境，通常仅用于开发和单元测试场景。 |



# 3.创建数据访问对象（DAO）

```java
@Mapper
@Repository
public interface UserMapper {

    /**
     * 查询所有用户
     *
     * @return 用户列表
     */
    @Select("SELECT * FROM orm_user")
    List<User> selectAllUser();

    /**
     * 根据id查询用户
     *
     * @param id 主键id
     * @return 当前id的用户，不存在则是 {@code null}
     */
    @Select("SELECT * FROM orm_user WHERE id = #{id}")
    User selectUserById(@Param("id") Long id);

    /**
     * 保存用户
     *
     * @param user 用户
     * @return 成功 - {@code 1} 失败 - {@code 0}
     */
    int saveUser(@Param("user") User user);

    /**
     * 删除用户
     *
     * @param id 主键id
     * @return 成功 - {@code 1} 失败 - {@code 0}
     */
    int deleteById(@Param("id") Long id);

}
```

配合的mapper文件

```xml-dtd
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xkcoding.orm.mybatis.mapper.UserMapper">

    <insert id="saveUser">
        INSERT INTO `orm_user` (`name`,
                                `password`,
                                `salt`,
                                `email`,
                                `phone_number`,
                                `status`,
                                `create_time`,
                                `last_login_time`,
                                `last_update_time`)
        VALUES (#{user.name},
                #{user.password},
                #{user.salt},
                #{user.email},
                #{user.phoneNumber},
                #{user.status},
                #{user.createTime},
                #{user.lastLoginTime},
                #{user.lastUpdateTime})
    </insert>

    <delete id="deleteById">
        DELETE
        FROM `orm_user`
        WHERE `id` = #{id}
    </delete>
</mapper>

```



## 常用MyBatis XML节点归纳

| 节点名字        | 功能                                                         | 例子                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `<select>`      | 定义查询语句                                                 | `<select id="selectUser" resultType="User">SELECT * FROM users WHERE id = #{id}</select>` |
| `<insert>`      | 定义插入语句                                                 | `<insert id="insertUser" parameterType="User">INSERT INTO users (id, username, email) VALUES (#{id}, #{username}, #{email})</insert>` |
| `<update>`      | 定义更新语句                                                 | `<update id="updateUser" parameterType="User">UPDATE users SET username = #{username}, email = #{email} WHERE id = #{id}</update>` |
| `<delete>`      | 定义删除语句                                                 | `<delete id="deleteUser" parameterType="Long">DELETE FROM users WHERE id = #{id}</delete>` |
| `<resultMap>`   | 定义结果集的映射关系                                         | `<resultMap id="userResultMap" type="User">...</resultMap>`  |
| `<result>`      | 定义结果集中的列与实体类属性的映射关系                       | `<result column="id" property="id" />`                       |
| `<association>` | 定义实体类中的复杂类型属性与关联表的映射关系                 | `<association property="address" javaType="Address">...</association>` |
| `<collection>`  | 定义实体类中的集合属性与关联表的映射关系                     | `<collection property="orders" ofType="Order">...</collection>` |
| `<if>`          | 定义条件判断，用于动态生成SQL语句                            | `<if test="name != null">AND name = #{name}</if>`            |
| `<choose>`      | 定义多个条件分支，类似于Java中的`switch`语句                 | `<choose><when test="status == 'ACTIVE'">...</when><otherwise>...</otherwise></choose>` |
| `<foreach>`     | 定义遍历集合或数组的元素，并生成对应的SQL片段                | `<foreach collection="list" item="item" separator=",">#{item}</foreach>` |
| `<sql>`         | 定义可重用的SQL片段                                          | `<sql id="userColumns">id, username, email</sql>`            |
| `<include>`     | 引用可重用的SQL片段                                          | `<select id="selectUser" resultType="User">SELECT <include refid="userColumns" /> FROM users WHERE id = #{id}</select>` |
| `<trim>`        | 定义去除SQL语句前后缀或中间某部分的功能，可用于动态拼接SQL语句 | `<trim prefix="AND" suffixOverrides="AND"><if test="name != null">name = #{name}</if></trim>` |


# 4.配置Mybatis

创建一个配置类（也可以直接使用yaml中的配置），配置MyBatis的扫描路径和其他相关配置。例如：

```java
@Configuration
@MapperScan("com.example.repository") // 指定 Mapper 接口的扫描路径
public class MyBatisConfig {

    @Autowired
    private DataSource dataSource;

    @Value("${mybatis.mapper-locations}")
    private String mapperLocations;

    @Value("${mybatis.type-aliases-package}")
    private String typeAliasesPackage;

    @Bean
    public SqlSessionFactory sqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource);
        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));
        sessionFactoryBean.setTypeAliasesPackage(typeAliasesPackage);

        // 设置 MyBatis 的配置
        Configuration configuration = new Configuration();
        configuration.setMapUnderscoreToCamelCase(true); // 将数据库字段名下划线转换为驼峰命名规则

        sessionFactoryBean.setConfiguration(configuration);

        return sessionFactoryBean.getObject();
    }

    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
```

